# Syntax describing the language
# Compile it to parser.yy.jl with julia ../parser/LexerParser.jl parser.syntax

# Convention : Upper case for terminals, lower case for non terminals
# Tip : Use Julia syntax highlighting to have colors

@lexer:
    # Ignored
    BLANK   -> "[\s][\s]*" : nothing
    COMMENT -> "#[.]*[\n]" : nothing

    # Punctuation
    LF      -> "[\n][\n]*" : (s) -> nothing
    COMMA   -> "," : (s) -> nothing
    LPAREN  -> "(" : (s) -> nothing
    RPAREN  -> ")" : (s) -> nothing

    # Keywords
    # TODO : If necessary, remove blanks at the end
    FUN     -> "fun[\b]" : (s) -> nothing
    TAKE    -> "take[\b]" : (s) -> nothing
    BEGIN   -> "begin[\b]" : (s) -> nothing
    END     -> "end[\b]" : (s) -> nothing
    LET     -> "let[\b]" : (s) -> nothing
    BE      -> "be[\b]" : (s) -> nothing
    RETURN  -> "return[\b]" : (s) -> nothing

    # Regexes
    ID      -> "[alpha][alnum]*" : (s) -> s
    INT     -> "-?[num][num]*" : (s) -> Base.parse(Int, s)

    # Operators
    SET     -> "[\:]=" : (s) -> nothing
    ADD     -> "+" : (s) -> nothing
    # SUB     -> "-" : (s) -> nothing
    MUL     -> "[\*]" : (s) -> nothing
    # DIV     -> "/" : (s) -> nothing

@parser:
    # Root of the AST
    root -> ctx : (ctx) -> ctx

    ctx -> decl : (decl) -> begin ctx = ctx_new(); push!(ctx.decls, decl); return ctx end
    ctx -> ctx decl : (ctx, decl) -> begin push!(ctx.decls, decl); return ctx end

    # --- Declarations ---
    decl -> declfun : (data) -> data
    decl -> declint : (data) -> data

    declint -> LET ID BE exp : (_, id, _, exp) -> decl_new(decltype_new(k_int_t), id, value=exp)

    declfun -> FUN ID line arglist line stmt : (_, id, _, args, _, body) -> decl_new(decltype_new(k_fn_t, args=args), id, body=body)
    declfun -> FUN ID line stmt : (_, id, _, body) -> decl_new(decltype_new(k_fn_t), id, body=body)

    # List of arguments for functions : take a, b, ...
    arglist -> TAKE ID : (_, id) -> [arg_new(id)]
    arglist -> arglist COMMA ID : (args, _, id) -> vcat(args, [arg_new(id)])

    # --- Statements ---
    # Statements are LF-terminated
    stmt -> stmtblock : (data) -> data
    stmt -> stmtdecl : (data) -> data
    stmt -> stmtexp : (data) -> data
    stmt -> stmtreturn : (data) -> data

    stmtblock -> stmtblock_begin endblock : (stmt, _) -> stmt
    stmtblock_begin -> stmtblock_begin stmt : (block, stmt) -> begin push!(block.stmts, stmt); return block end
    stmtblock_begin -> beginblock : (_) -> stmt_newblock()

    stmtdecl -> decl line : (decl, _) -> stmt_newdecl(decl)

    stmtexp -> exp line : (exp, _) -> stmt_newexp(exp)

    stmtreturn -> RETURN exp line : (_, exp, _) -> stmt_newreturn(exp)

    # --- Expressions ---
    exp -> int9 : (data) -> data

    # TODO : int8
    int9 -> int4 : (data) -> data
    int9 -> unary SET exp : (lhs, _, data) -> exp_newset(lhs, data)

    # int<precedance>
    int4 -> int3 : (data) -> data
    int4 -> int4 ADD int3 : (l, _, r) -> exp_newadd(l, r)

    int3 -> int2 : (data) -> data
    int3 -> int3 MUL int2 : (l, _, r) -> exp_newmul(l, r)

    int2 -> int1 : (data) -> data

    # TODO : Verify
    int1 -> primary : (data) -> data
    int1 -> LPAREN int9 RPAREN : (_, data, _) -> data

    unary -> primary : (data) -> data

    primary -> ID : (name) -> exp_newid(name)
    primary -> INT : (val) -> exp_newint(val)

    # --- Misc ---
    line -> LF : (_) -> nothing
    line -> line LF : (_, _) -> nothing

    beginblock -> BEGIN : (_) -> nothing
    beginblock -> beginblock line : (_, _) -> nothing

    endblock -> END : (_) -> nothing
    endblock -> endblock line : (_, _) -> nothing
