# Syntax describing the language
# Compile it to parser.yy.jl with julia ../parser/LexerParser.jl parser.syntax

# Convention : Upper case for terminals, lower case for non terminals
# Tip : Use Julia syntax highlighting to have colors

@lexer:
    # Ignored
    BLANK   -> "[\s][\s]*" : nothing
    COMMENT -> "#[.]*" : nothing

    # Punctuation
    LF      -> "[\n][\n]*" : (s) -> nothing
    COMMA   -> "," : (s) -> nothing
    LPAREN  -> "(" : (s) -> nothing
    RPAREN  -> ")" : (s) -> nothing

    # Keywords
    FUN     -> "fun[\b]" : (s) -> nothing
    PROC    -> "proc[\b]" : (s) -> nothing
    TAKE    -> "take[\b]" : (s) -> nothing
    BEGIN   -> "begin[\b]" : (s) -> nothing
    END     -> "end[\b]" : (s) -> nothing
    LET     -> "let[\b]" : (s) -> nothing
    BE      -> "be[\b]" : (s) -> nothing
    IS      -> "is[\b]" : (s) -> nothing
    RETURN  -> "return[\b]" : (s) -> nothing
    IF      -> "if[\b]" : (s) -> nothing
    ELSE    -> "else[\b]" : (s) -> nothing
    LOOP    -> "loop[\b]" : (s) -> nothing
    WITH    -> "with[\b]" : (s) -> nothing
    WHEN    -> "when[\b]" : (s) -> nothing

    # TODO : If necessary, remove blanks at the end (and test whether naming a variable true... is possible)
    # Try otherwise in the parser : ID -> true ID
    TRUE    -> "true" : (s) -> nothing
    FALSE   -> "false" : (s) -> nothing

    # Regexes
    ID      -> "[alpha][alnum]*" : (s) -> s
    INT     -> "-?[num][num]*" : (s) -> Base.parse(Int, s)

    # Operators
    SET     -> "[\:]=" : (s) -> nothing
    ADD     -> "+" : (s) -> nothing
    # SUB     -> "-" : (s) -> nothing
    MUL     -> "[\*]" : (s) -> nothing
    # DIV     -> "/" : (s) -> nothing
    NE      -> "!=" : (s) -> nothing
    LE      -> "<=" : (s) -> nothing
    LT      -> "<" : (s) -> nothing
    GE      -> ">=" : (s) -> nothing
    GT      -> ">" : (s) -> nothing

@parser:
    # Root of the AST
    root -> ctx : (ctx) -> ctx

    ctx -> decl : (decl) -> begin ctx = ctx_new(); push!(ctx.decls, decl); return ctx end
    ctx -> ctx decl : (ctx, decl) -> begin push!(ctx.decls, decl); return ctx end

    # --- Declarations ---
    decl -> declfun : (data) -> data
    decl -> declproc : (data) -> data
    decl -> declint : (data) -> data

    declint -> LET ID BE exp : (_, id, _, exp) -> decl_new(decltype_new(k_int_t), id, value=exp)

    declfun -> FUN ID line arglist line stmt : (_, id, _, args, _, body) -> decl_new(decltype_new(k_fn_t, args=args), id, body=body)
    declfun -> FUN ID line stmt : (_, id, _, body) -> decl_new(decltype_new(k_fn_t), id, body=body)

    declproc -> PROC ID line arglist line stmt : (_, id, _, args, _, body) -> decl_new(decltype_new(k_proc_t, args=args), id, body=body)
    declproc -> PROC ID line stmt : (_, id, _, body) -> decl_new(decltype_new(k_proc_t), id, body=body)

    # List of arguments for functions : take a, b, ...
    arglist -> TAKE ID : (_, id) -> [arg_new(id)]
    arglist -> arglist COMMA ID : (args, _, id) -> vcat(args, [arg_new(id)])

    # --- Statements ---
    # Statements are LF-terminated
    stmt -> stmtblock : (data) -> data
    stmt -> stmtdecl : (data) -> data
    stmt -> stmtexp : (data) -> data
    stmt -> stmtreturn : (data) -> data
    stmt -> stmtif : (data) -> data
    stmt -> stmtloop : (data) -> data

    stmtblock -> stmtblock_begin endblock : (stmt, _) -> stmt
    stmtblock_begin -> stmtblock_begin stmt : (block, stmt) -> begin push!(block.stmts, stmt); return block end
    stmtblock_begin -> beginblock : (_) -> stmt_newblock()

    stmtdecl -> decl line : (decl, _) -> stmt_newdecl(decl)

    stmtexp -> exp line : (exp, _) -> stmt_newexp(exp)

    stmtreturn -> RETURN exp line : (_, exp, _) -> stmt_newreturn(exp)

    stmtif -> IF exp line stmt : (_, condition, _, iftrue) -> stmt_newifelse(condition, iftrue)
    stmtif -> IF exp line stmt ELSE stmt : (_, condition, _, iftrue, _, iffalse) -> stmt_newifelse(condition, iftrue, iffalse)

    # While
    # TODO : Check nothing is possible in init / iter
    stmtloop -> LOOP WHEN exp line stmt : (_, _, condition, _, body) -> stmt_newloop(nothing, condition, nothing, body)

    # --- Expressions ---
    exp -> int9 : (data) -> data

    # int<precedance>
    int9 -> int8 : (data) -> data
    int9 -> unary SET exp : (lhs, _, data) -> exp_newset(lhs, data)

    int8 -> int7 : (data) -> data

    int7 -> int6 : (data) -> data

    int6 -> int5 : (data) -> data
    int6 -> int6 IS int5 : (l, _, r) -> exp_newtest(l, "e", r)
    int6 -> int6 NE int5 : (l, _, r) -> exp_newtest(l, "ne", r)

    int5 -> int4 : (data) -> data
    # TODO : Verify operator type
    int5 -> int5 LE int4 : (l, _, r) -> exp_newtest(l, "le", r)
    int5 -> int5 LT int4 : (l, _, r) -> exp_newtest(l, "lt", r)
    int5 -> int5 GE int4 : (l, _, r) -> exp_newtest(l, "ge", r)
    int5 -> int5 GT int4 : (l, _, r) -> exp_newtest(l, "gt", r)

    int4 -> int3 : (data) -> data
    int4 -> int4 ADD int3 : (l, _, r) -> exp_newadd(l, r)

    int3 -> int2 : (data) -> data
    int3 -> int3 MUL int2 : (l, _, r) -> exp_newmul(l, r)

    int2 -> int1 : (data) -> data

    # TODO : Verify
    int1 -> primary : (data) -> data
    int1 -> LPAREN int9 RPAREN : (_, data, _) -> data

    unary -> primary : (data) -> data

    primary -> ID : (name) -> exp_newid(name)
    primary -> INT : (val) -> exp_newint(val)
    primary -> TRUE : (_) -> exp_newint(1)
    primary -> FALSE : (_) -> exp_newint(0)

    # --- Misc ---
    line -> LF : (_) -> nothing
    line -> line LF : (_, _) -> nothing

    beginblock -> BEGIN : (_) -> nothing
    beginblock -> beginblock line : (_, _) -> nothing

    endblock -> END : (_) -> nothing
    endblock -> endblock line : (_, _) -> nothing
