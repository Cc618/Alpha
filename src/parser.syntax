# Syntax describing the language
# Compile it to parser.yy.jl with julia ../parser/LexerParser.jl parser.syntax

# Convention : Upper case for terminals, lower case for non terminals

@lexer:
    # LPAREN  -> "(" : (s) -> nothing
    # RPAREN  -> ")" : (s) -> nothing
    # PLUS    -> "+" : (s) -> nothing
    # TIMES   -> "[\*]" : (s) -> nothing
    # INT     -> "-?[num][num]*" : (s) -> Base.parse(Int, s)
    # BLANK   -> "[\s][\s]*" : nothing

    # Ignored
    BLANK   -> "[\s][\s]*" : nothing

    # Punctuation
    # TODO : Don't ignore
    LF      -> "[\n]" : nothing
    COMMA   -> "," : (s) -> nothing

    # Keywords
    # TODO : If necessary, remove blanks at the end
    FUN     -> "fun[\b]" : (s) -> nothing
    TAKE    -> "take[\b]" : (s) -> nothing
    BEGIN   -> "begin[\b]" : (s) -> nothing
    END     -> "end[\b]" : (s) -> nothing

    # Regexes
    ID      -> "[alpha][alnum]*" : (s) -> s

@parser:
    # Root of the AST
    root -> ctx : (ctx) -> ctx

    ctx -> decl : (decl) -> begin ctx = ctx_new(); push!(ctx.decls, decl); return ctx end
    ctx -> ctx decl : (ctx, decl) -> begin push!(ctx.decls, decl); return ctx end

    # TODO : Line feed

    # Declaration
    decl -> FUN ID arglist stmt : (_, id, args, body) -> decl_new(decltype_new(k_fn_t, args=args), id, body=body)
    decl -> FUN ID stmt : (_, id, body) -> decl_new(decltype_new(k_fn_t), id, body=body)

    # List of arguments for functions : take a, b, ...
    arglist -> TAKE ID : (_, id) -> [arg_new(id)]
    arglist -> arglist COMMA ID : (args, _, id) -> vcat(args, [arg_new(id)])

    # TODO : stmtblock
    stmt -> BEGIN END : (_, _) -> 42






    # # Root of the AST
    # a -> e : (val) -> val
    # # Expression (+ priority)
    # e -> e PLUS t : (a, _, b) -> a + b
    # e -> t : (val) -> val
    # # Term (* priority)
    # t -> t TIMES f : (a, _, b) -> a * b
    # t -> f : (val) -> val
    # # Factor (explicit or leftmost priority)
    # f -> LPAREN e RPAREN : (_, val, _) -> val
    # f -> N : (val) -> val
